/*
 * main.c
 *
 *  Created on: 2013/02/09
 *      Author: mizu
 */


/********************************************************************************
 *
********************************************************************************/

/**
 * デバイスID
 * 	デバイスの種類を示すもので、デバイスタイプの決定に利用される
 * 	各デバイスにはそれぞれ任意のドライバが割り当てられているとする
 */
enum dev_id
{
	cpu,
	memory,
	storage,
	network,
	serial,
	gpio,
};

/**
 * デバイスタイプ
 * 	デバイスタイプによって read write による
 * 	読み込み・書き込み先 が変化する、何れにしてもバッファの読み書きにとどまる
 */
enum dev_type
{
	stdio,
	graphics,
	gpio,
};


/********************************************************************************
 *
********************************************************************************/

/**
 * この read, writeはユーザーが利用するライブラリの中に埋め込まれる
 */
//(void*)(0x40000)
void (*write)(/* dev_type, char c */);
char (*read)(/* dev_type */);

void pinoc_init()
{
	/**
	 * システムコールの初期化
	 * 関数ポインタを特定のアドレスに設置する
	 */
	write = syscall_write;
	read = syscall_read;

}

/**
 * デバイスタイプのバッファに出力する共通関数
 * アプリケーションの中核をなす
 * システムコールはユーザープログラムとOS自信から呼ばれる
 */
void syscall_write(/* dev_type, char c */)
{
	/**
	 * システムコールを呼ぶことで全ての読み込みを行う
	 */
}

char syscall_read(/* dev_type */)
{
}

/**
 * バッファの更新はOS自信のタイミングで行い
 * システムコールでユーザーアプリケーションから実行されることはないｓ
 * syscall_で始まる関数以外は本来はプロテクトモードで保護される
 */
void update_buff()
{
	/**
	 * updateによってデバイスタイプのバッファが処理される
	 *
	 * デバイスIDからドライバが選択される
	 */
}

/********************************************************************************
 *
********************************************************************************/
/**
 * このように、あらかじめドライバ関数テーブルをつくり、まとめておく
 * デバイスIDとテーブルを一致させることで、デバイスとドライバを関連付けさせる
 */
void (*t_serial_init)();
void (*t_serial_read)();
void (*t_serial_write)();
void (*t_gpio_init)();
void (*t_gpio_read)();
void (*t_gpio_write)();
// etc....
// etc..
// etc.

/**
 * デバイスのりよう許可を管理するテーブル
 */
char dev_flg[] = {0,};


void init_port(){}

void dev_add(/* dev_id, std_init, std_read, std_write */)
{
	/**
	 * ドライバ関数のテーブルに各、基本的な関数を登録する
	 */
}

void dev_open(/* dev_id */)
{
	/** 1
	 * ドライバ関数のテーブルから、デバイスIDにマッチする適切な関数 *_initを実行する
	 * *_initを行うことでレジスタは設定されデバイスは利用可能になる
	 */

	/** 2
	 * デバイス管理テーブルとデバイスIDが一致する場所のフラグを立てる
	 * フラグがたつことで各、バッファにアクセスできるようになる
	 */
}

void dev_close()
{
	/** 1
	 * デバイス管理テーブルとデバイスIDが一致する場所のフラグを下げる
	 * フラグが下がることで、各バッファと切断される
	 */
}


/*■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
 * sample
 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■*/
/**
 * 基本的な関数はドライバとして機能する
 */
void serial_init(){}
void serial_write(){}
void serial_read(){}
void gpio_init(){}
//etc...
//etc.

/**
 * スタックや各セクションを初期化してmainにjmpするとする
 * シリアルデバイス と 汎用ポートを利用するとする
 */

/**
 * main OS部分
 */
void main()
{
	char c;

	/*******************************************
	 * 				ココから読む
	 *******************************************/

	/**
	 * システムコール呼び出しテーブルを初期化する
	 * 	OSとユーザープログラムがどちらも知っている関数ポインタのテーブルを利用して
	 * 	ユーザーアプリケーションからシステムコールするために必要
	 */
	pinoc_init();

	/**
	 * ポート番号テーブルを初期化する
	 * 	マイコンにある足が現在何に割り当てられているか管理するテーブル
	 */
	init_port();

	/**
	 * デバイスIDを元にデバイスタイプが適応される stdio
	 * serialはstdioとして登録される
	 * dev_addによってポート番号が利用中の状態になる
	 * 基本的な３つの関数「init read write」を登録する。使い勝手から共有ライブラリ式は無しとする
	 */
	dev_add(/* serial_id, port_no, std_init, std_read, std_write */);		///< シリアルデバイスを登録する
	dev_add(/* gpio_id, etc... */);											///< gpioデバイスを登録する

	/**
	 * デバイスの初期化が行われ、利用許可フラグを立てる
	 */
	dev_open(/* serial_id */);		///< シリアルデバイスを利用開始する
	dev_open(/* gpio_id */);		///< gpioデバイスを利用開始する

	while(1)
	{
		/**
		 * デバイスタイプから読み込む
		 * serialはstdioとして動く
		 * stdioはバッファであって、割り込みによって自然に溜まっていく
		 * 他のデバイス例えばSPIやI2Cでも同じ
		 * 液晶でもコンソール型はstdioとして動かすとする
		 */
		c = read(/* type_stdio */);

		/**
		 * TESTのシュミレーション
		 */
		switch(c)
		{
		case 1:
			/**
			 * デバイスを問題なく終了させ、利用許可フラグを下げる
			 * stdioがなくなるわけではなく、stdioにアクセスできなくなる
			 */
			dev_close(/* serial_id */);		///< デバイスを利用停止する
			dev_close(/* gpio_dev */);
			break;

		case 2:
			/**
			 * デバイスに書き込む
			 * この場合、stdioを通してデバイスに書き込む
			 * stdioはバッファであって、XXXによって自然に出力される
			 */
			write(/* type_stdio, 'A' */);

			/**
			 * dev_typeに登録されているバッファを更新する
			 * 本来は定期的にバックグラウンドで実行される
			 * stdioにserialが登録されているのであれば
			 * serialドライバを利用し、バッファが出力される
			 */
			update_buff();
			break;

		}


	}
}

/**
 * OSを利用してユーザープログラムを動かすとする
 * プログラムはOSとは別でコンパイルされており一つの実行ファイルとして存在するとする
 * SDカードやXMODEMでRAM上にこのプログラムは展開されているとする
 */
void user_main()
{
	/**
	 * シリアルを出力するとする
	 */

	/**
	 * ユーザーはハードウェアのことを意識せずにプログラムをかくとする
	 * OS部分で、stdioはシリアルデバイスに登録されているのでシリアルからバッファが出力される
	 * writeの中では、stdioが何であるか特定するために予め決まっているメモリ番地を利用してシステムコールを行う
	 * 基本的に全て、OS(update_buff)がデバイスにアクセスし、ユーザープログラムはシステムコールを呼ぶだけ
	 */
	write(/* stdio, 'B' */);
	while(1);
}
