/***********************************************************************/
/*                                                                     */
/*  FILE        :lowsrc.c                                              */
/*  DATE        :Thu, Feb 21, 2013                                     */
/*  DESCRIPTION :Program of I/O Stream                                 */
/*  CPU TYPE    :H8/3069R                                              */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.16).    */
/*                                                                     */
/***********************************************************************/
                  



#include <string.h>
#include <stdio.h>
#include <stddef.h>
#include "typedefine.h"
#include "lowsrc.h"

#if __STDC_VERSION__ == 199901L
#ifndef _STDIO_C89
/* ファイル番号 */
#define STDIN  0                    /* 標準入力           (コンソール) */
#define STDOUT 1                    /* 標準出力           (コンソール) */
#define STDERR 2                    /* 標準エラー出力     (コンソール) */

#define FLMIN  0                    /* 最小のファイル番号              */
#define _MOPENR	0x1
#define _MOPENW	0x2
#define _MOPENA	0x4
#define _MTRUNC	0x8
#define _MCREAT	0x10
#define _MBIN	0x20
#define _MEXCL	0x40
#define _MALBUF	0x40
#define _MALFIL	0x80
#define _MEOF	0x100
#define _MERR	0x200
#define _MLBF	0x400
#define _MNBF	0x800
#define _MREAD	0x1000
#define _MWRITE	0x2000
#define _MBYTE	0x4000
#define _MWIDE	0x8000
/* ファイルフラグ */
#define O_RDONLY 0x0001 /* 読み込み専用にオープン                      */
#define O_WRONLY 0x0002 /* 書き出し専用にオープン                      */
#define O_RDWR   0x0004 /* 読み書き、両用にオープン                    */
#define O_CREAT  0x0008 /* ファイルが存在しない場合、新規作成          */
#define O_TRUNC  0x0010 /* ファイルが存在する場合、ファイルサイズを0に */
#define O_APPEND 0x0020 /* 次に読み書きを行うファイル内の位置を設定    */
                        /* 0：ファイルの先頭  1：ファイルの最後        */

/* 特殊文字コード */
#define CR 0x0d                     /* 復帰                            */
#define LF 0x0a                     /* 改行                            */

const int _nfiles = IOSTREAM;  /* 入出力ファイル数を指定               */
char flmod[IOSTREAM];          /* オープンしたファイルのモード設定場所 */

unsigned char sml_buf[IOSTREAM];

#define FPATH_STDIN     "C:\\stdin"
#define FPATH_STDOUT    "C:\\stdout"
#define FPATH_STDERR    "C:\\stderr"

/* H8ノーマルモード・SH・RX */
#if defined( __2000N__ ) || defined( __2600N__ ) || defined( __300HN__ ) || defined( _SH ) || defined( __RX )
/* 標準入力からの1文字入力処理 */
extern void charput(char);
/* 標準出力への1文字出力処理 */
extern char charget(void);
/* ファイルへの1文字出力処理 */
extern char fcharput(char, unsigned char);
/* ファイルからの1文字入力処理 */
extern char fcharget(char*, unsigned char);
/* ファイルのオープン */
extern char fileopen(char*, unsigned char, unsigned char*);
/* ファイルのクローズ */
extern char fileclose(unsigned char);
/* ファイルポインタの移動 */
extern char fpseek(unsigned char, long, unsigned char);
/* ファイルポインタの取得 */
extern char fptell(unsigned char, long*);

/* H8アドバンストモード */
#elif defined( __2000A__ ) || defined( __2600A__ ) || defined( __300HA__ ) || defined( __H8SXN__ ) || defined( __H8SXA__ ) || defined( __H8SXM__ ) || defined( __H8SXX__ )
/* 標準入力からの1文字入力処理 */
extern void charput(char);
/* 標準出力への1文字出力処理 */
extern char charget(void);
/* ファイルへの1文字出力処理 */
extern char fcharput(char, unsigned char);
/* ファイルからの1文字入力処理 */
extern char fcharget(char*, unsigned char);
/* ファイルのオープン */
/* 引数格納レジスタ3指定 */
extern char __regparam3 fileopen(char*, unsigned char, unsigned char*);
/* ファイルのクローズ */
extern char fileclose(unsigned char);
/* ファイルポインタの移動 */
extern char fpseek(unsigned char, long, unsigned char);
/* ファイルポインタの取得 */
extern char fptell(unsigned char, long*);

/* H8300・H8300L */
#elif defined( __300__ ) || defined( __300L__ )
/* 標準入力からの1文字入力処理 */
extern void charput(char);
/* 標準出力への1文字出力処理 */
extern char charget(void);
/* ファイルへの1文字出力処理 */
extern char fcharput(char, unsigned char);
/* ファイルからの1文字入力処理 */
extern char fcharget(char*, unsigned char);
/* ファイルのオープン */
/* 引数格納レジスタ3指定 */
extern char __regparam3 fileopen(char*, unsigned char, unsigned char*);
/* ファイルのクローズ */
extern char fileclose(unsigned char);
/* ファイルポインタの移動 */
/* 引数格納レジスタ3指定 */
extern char __regparam3 fpseek(unsigned char, long, unsigned char);
/* ファイルポインタの取得 */
extern char fptell(unsigned char, long*);
#endif

#include <stdio.h>
FILE *_Files[IOSTREAM]; // ファイル構造体
char *env_list[] = { //環境変数文字列配列(**environ)
    "ENV1=temp01",
    "ENV2=temp02",
    "ENV9=end",
    '\0'            // 環境変数配列終端NULL
};

char **environ = env_list;

/****************************************************************************/
/* _INIT_IOLIB                                                              */
/*  Initialize C library Functions, if necessary.                           */
/*  Define USES_SIMIO on Assembler Option.                                  */
/****************************************************************************/
void _INIT_IOLIB( void )
{
    /* 標準入出力用ファイルをオープン、または生成します。各FILE構造体の     */
    /* 初期化はライブラリ内で行っています。各ファイル構造体の_Bufメンバに   */
    /* freopen()によってリセットされたバッファ最終ポインタを再設定します。  */

    /* 標準入力用ファイル                                                   */
    if( freopen( FPATH_STDIN, "r", stdin ) == NULL )
        stdin->_Mode = 0xffff;          /* オープン失敗時のアクセス禁止     */
    stdin->_Mode |= _MOPENR;            /* ファイルを読み込み専用に設定     */
    stdin->_Mode |= _MNBF;              /* データのバッファリングなしに設定 */
    stdin->_Bend = stdin->_Buf + 1;     /* バッファ最終ポインタの再設定     */

    /* 標準出力用ファイル                                                   */
    if( freopen( FPATH_STDOUT, "w", stdout ) == NULL ) 
        stdout->_Mode = 0xffff;         /* オープン失敗時のアクセス禁止     */
    stdout->_Mode |= _MNBF;             /* データのバッファリングなしに設定 */
    stdout->_Bend = stdout->_Buf + 1;   /* バッファ最終ポインタの再設定     */
    
    /* 標準エラー出力用ファイル                                             */
    if( freopen( FPATH_STDERR, "w", stderr ) == NULL )
        stderr->_Mode = 0xffff;         /* オープン失敗時のアクセス禁止     */
    stderr->_Mode |= _MNBF;             /* データのバッファリングなしに設定 */
    stderr->_Bend = stderr->_Buf + 1;   /* バッファ最終ポインタの再設定     */
}

/****************************************************************************/
/* _CLOSEALL                                                                */
/****************************************************************************/
void _CLOSEALL( void )
{
    int i;

    for( i=0; i < _nfiles; i++ )
    {
        /* ファイルがオープンしているかチェック                              */
        if( _Files[i]->_Mode & (_MOPENR | _MOPENW | _MOPENA ) )
        fclose( _Files[i] );    /* ファイルをクローズする                    */
    }
}

/**************************************************************************/
/*       open:file open                                                   */
/*          Return value:File number (Pass)                               */
/*                       -1          (Failure)                            */
/**************************************************************************/
int open(char *name,                        /* ファイル名                     */
     int  mode,                         /* オープンモード                 */
     int  flg)                          /* オープンフラグ                 */
{

   
    if( strcmp( name, FPATH_STDIN ) == 0 )      /* 標準入力ファイル       */
    {
        if( ( mode & O_RDONLY ) == 0 ) return -1;
        flmod[STDIN] = mode;
        return STDIN;
    }
    else if( strcmp( name, FPATH_STDOUT ) == 0 )/* 標準出力ファイル       */
    {
        if( ( mode & O_WRONLY ) == 0 ) return -1;
        flmod[STDOUT] = mode;
        return STDOUT;
    }
    else if(strcmp(name, FPATH_STDERR ) == 0 )  /* 標準エラー出力ファイル */
    {
        if( ( mode & O_WRONLY ) == 0 ) return -1;
        flmod[STDERR] = mode;
        return STDERR;
    }
    else return -1;                             /*標準入出力以外のファイル*/
}

int close( int fileno )
{
    return 1;
}

/**************************************************************************/
/* write:Data write                                                       */
/*  Return value:Number of write characters (Pass)                        */
/*               -1                         (Failure)                     */
/**************************************************************************/
int write(int  fileno,                  /* ファイル番号                   */
      char *buf,                        /* 転送先バッファアドレス         */
      int  count)                       /* 書き出し文字数                 */
{
    unsigned int    i;                  /* カウント用変数                 */
    char             c;                 /* 出力文字                       */

    /* ファイルのモードをチェックし、一文字づつ出力                       */
    /* 書き出し専用 or 読み込み書き出し両用にオープンされているか判定     */
    if(flmod[fileno]&O_WRONLY || flmod[fileno]&O_RDWR)
    {
        if( fileno == STDIN ) return -1;            /* 標準入力           */
        else if( (fileno == STDOUT) || (fileno == STDERR) ) /* 標準出力   */
        {
            for( i = count; i > 0; --i )
            {
                c = *buf++;
                charput(c);
            }
            return count;                /* 書き出した文字数返却。        */
        }
        else return -1;                  /* ファイル出力                  */
    }
    else return -1;                      /* エラー                        */
}

int read( int fileno, char *buf, unsigned int count )
{
	   unsigned int i;

       /* ファイル番号に従ってモードをチェックし、一文字づつ入力してバッファに格納 */

       if((flmod[fileno]&_MOPENR) || (flmod[fileno]&O_RDWR)){
             for(i = count; i > 0u; i--){
                   *buf = charget();
                   if(*buf==CR){              /* 改行文字の置き換え */
                         *buf = LF;
                   }
                   buf++;
             }
             return count;
       }
       else {
             return -1;
       }
}

long lseek( short fileno, short offset, short base )
{
    return -1L;
}

#define _DONE
#endif
#endif

#ifdef _DONE
#undef _DONE
#else
_SINT open(_SBYTE *name, _SINT mode, _SINT flg);
_SINT close(_SINT fileno);
_SINT read(_SINT fileno, _SBYTE *buf, _UINT count);
_SINT write(_SINT fileno, _SBYTE *buf, _UINT count);
_SDWORD lseek(_SINT fileno, _SDWORD offset, _SINT base);
void _INIT_IOLIB(void);
void _CLOSEALL(void);


/* ファイル番号 */

#define STDIN  0        /* 標準入力      （コンソール） */
#define STDOUT 1        /* 標準出力      （コンソール） */
#define STDERR 2        /* 標準エラー出力（コンソール） */

#define FLMIN  0               /* 最小のファイル番号 */
#define FLMAX  (IOSTREAM-1)    /* 最大のファイル番号 */

/* ファイルのフラグ */

#define O_RDONLY 0x0001     /* 読み込み専用 */
#define O_WRONLY 0x0002     /* 書き出し専用 */
#define O_RDWR   0x0004     /* 読み書き両用 */

/* 特殊文字コード */

#define CR 0x0d     /* 復帰     */
#define LF 0x0a     /* 改行     */

const _SINT _nfiles = IOSTREAM;
struct _iobuf _iob[IOSTREAM];
_UBYTE sml_buf[IOSTREAM];


/*************************************************************************/
/* 参照関数の宣言：                                                      */
/* シミュレータ・デバッガでコンソールへの文字入出力を行う                */
/*   アセンブリプログラムの参照                                          */
/*************************************************************************/
extern void charput(_SBYTE);     /* 一文字出力処理     */
extern _SBYTE charget(void);     /* 一文字入力処理     */

/*************************************************************************/
/* 静的変数の定義：                                                      */
/* 低水準インタフェースルーチンで使用する静的変数の定義                  */
/*************************************************************************/
_SBYTE flmod[IOSTREAM];      /* オープンしたファイルのモード設定場所  */

/*************************************************************************/
/*  open:ファイルのオープン                                              */
/*        リターン値：ファイル番号（成功）                               */
/*                    -1          （失敗）                               */
/*************************************************************************/
_SINT open(_SBYTE *name,               /* ファイル名         */
     _SINT  mode,                      /* ファイルのモード   */
     _SINT  flg)                       /* 未使用             */
{
       /* ファイル名に従ってモードをチェックし、ファイル番号を返す */

       if(strcmp((const char *) name,"stdin")==0){          /* 標準入力ファイル   */
             if((mode&O_RDONLY)==0){
                      return -1;
             }
             flmod[STDIN] = mode;
             return STDIN;
       }

       else if(strcmp((const char *) name,"stdout")==0){   /* 標準出力ファイル */
             if((mode&O_WRONLY)==0){
                      return -1;
             }
             flmod[STDOUT] = mode;
             return STDOUT;
       }

       else if(strcmp((const char *) name,"stderr")==0){   /* 標準エラー出力ファイル */
             if((mode&O_WRONLY)==0){
                      return -1;
             }
             flmod[STDERR] = mode;
             return STDERR;
       }

       else {
             return -1;     /* エラー */
       }
}

/*************************************************************************/
/*  close:ファイルのクローズ                                             */
/*       リターン値：0          （成功）                                 */
/*                   -1         （失敗）                                 */
/*************************************************************************/
_SINT close(_SINT fileno)              /* ファイル番号 */
{
       if((fileno<FLMIN) || (FLMAX<fileno)){ /* ファイル番号の範囲チェック */
             return -1;
       }
       flmod[fileno] = 0;              /* ファイルのモードリセット */
       return 0;
}

/*************************************************************************/
/*  read:データの読み込み                                                */
/*        リターン値：実際に読み込んだ文字数 （成功）                    */
/*        		      -1 （失敗）                                        */
/*************************************************************************/
_SINT read(_SINT fileno,          /* ファイル番号           */
     _SBYTE *buf,                 /* 転送先バッファアドレス */
     _UINT count)                 /* 読み込み文字数         */
{
       _UINT i;

       /* ファイル番号に従ってモードをチェックし、一文字づつ入力してバッファに格納 */

       if((flmod[fileno]&O_RDONLY) || (flmod[fileno]&O_RDWR)){
             for(i = count; i > 0u; i--){
                   *buf = charget();
                   if(*buf==CR){              /* 改行文字の置き換え */
                         *buf = LF;
                   }
                   buf++;
             }
             return count;
       }
       else {
             return -1;
       }
}
 
/*************************************************************************/
/*  write:データの書き出し                                               */
/*  	リターン値：実際に書き出した文字数  （成功）                     */
/*  		        -1  （失敗）                                         */
/*************************************************************************/
_SINT write(_SINT fileno,              /* ファイル番号           */
     _SBYTE *buf,                      /* 転送元バッファアドレス */
     _UINT count)                      /* 書き出し文字数         */
{
       _UINT i;
       _SBYTE c;

       /* ファイル番号に従ってモードをチェックし、一文字づつ出力 */

       if((flmod[fileno]&O_WRONLY) || (flmod[fileno]&O_RDWR)){
             for(i = count; i > 0u; i--){
                   c = *buf++;
                   charput(c);
             }
             return count;
       }
       else {
             return -1;
       }
}

/******************************************************************************/
/*  lseek:ファイルの読み込み／書き出し位置の設定                              */
/*    リターン値：読み込み／書き出し位置のファイル先頭からのオフセット（成功）*/
/*                -1  （失敗）                                                */
/*      (コンソール入出力では、lseekはサポートしていません)                   */
/******************************************************************************/
_SDWORD lseek(_SINT fileno,            /* ファイル番号           */
       _SDWORD offset,                 /* 読み込み／書き出し位置 */
       _SINT base)                     /* オフセットの起点       */
{
       return -1L;
}

/****************************************************************************/
/* _INIT_IOLIB                                                              */
/****************************************************************************/
void _INIT_IOLIB(void)
{
       FILE *fp;

       for(fp = _iob; fp < _iob+_nfiles; fp++){
             fp->_bufptr = NULL;
             fp->_bufcnt = 0L;
             fp->_buflen = 0L;
             fp->_bufbase = NULL;
             fp->_ioflag1 = 0;
             fp->_ioflag2 = 0;
             fp->_iofd = 0;
       }

       if(freopen("stdin", "r", stdin)==NULL){
             stdin->_ioflag1 = 0xff;
       }
       stdin->_ioflag1 |= _IOUNBUF;

       if(freopen("stdout", "w", stdout)==NULL){
             stdout->_ioflag1 = 0xff;
       }
       stdout->_ioflag1 |= _IOUNBUF;

       if(freopen("stderr", "w", stderr)==NULL){
             stderr->_ioflag1 = 0xff;
       }
       stderr->_ioflag1 |= _IOUNBUF;
}

/****************************************************************************/
/* _CLOSEALL                                                                */
/****************************************************************************/
void _CLOSEALL(void)
{
       _SINT i;

       for(i = 0; i < _nfiles; i++){
             if(_iob[i]._ioflag1 & (_IOREAD | _IOWRITE | _IORW )){
                   fclose(&_iob[i]);
             }
       }
}
#endif
